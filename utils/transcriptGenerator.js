'use strict';

const tdb = require('./ticketDatabase');

/**
 * Generates a styled HTML transcript from a ticket's message history.
 *
 * Two sources are supported:
 *   - fromChannel: fetches live messages from Discord (preferred, used on /ticket close)
 *   - fromDatabase: uses the DB-tracked message log (fallback when channel is deleted)
 */
class TranscriptGenerator {

    /**
     * @param {import('discord.js').TextChannel|import('discord.js').ThreadChannel} channel
     * @param {object} ticket
     * @param {import('discord.js').Guild} guild
     * @returns {Promise<Buffer>}
     */
    async fromChannel(channel, ticket, guild) {
        const messages = await this._fetchAllMessages(channel);
        return this._buildHTML(messages, ticket, guild);
    }

    /**
     * @param {object} ticket
     * @param {import('discord.js').Guild} guild
     * @returns {Buffer}
     */
    fromDatabase(ticket, guild) {
        const rows     = tdb.getTicketMessages(ticket.id);
        const messages = rows.map(r => ({
            id:          r.message_id,
            authorId:    r.author_id,
            authorTag:   r.author_tag,
            authorAvatar: null,
            isBot:       r.author_bot === 1,
            content:     r.content,
            attachments: JSON.parse(r.attachments || '[]'),
            embedCount:  r.embeds,
            timestamp:   new Date(r.created_at * 1000),
        }));
        return this._buildHTML(messages, ticket, guild);
    }

    // -------------------------------------------------------------------------

    async _fetchAllMessages(channel) {
        const all    = [];
        let   lastId = null;

        // Discord returns up to 100 messages per request; paginate until exhausted.
        while (true) {
            const batch = await channel.messages.fetch({ limit: 100, ...(lastId && { before: lastId }) });
            if (batch.size === 0) break;
            all.push(...batch.values());
            lastId = batch.last().id;
            if (batch.size < 100) break;
        }

        return all.reverse().map(m => ({
            id:          m.id,
            authorId:    m.author.id,
            authorTag:   m.author.tag,
            authorAvatar: m.author.displayAvatarURL({ size: 32, extension: 'png' }),
            isBot:       m.author.bot,
            content:     m.content,
            attachments: m.attachments.map(a => ({ url: a.url, name: a.name, contentType: a.contentType })),
            embedCount:  m.embeds.length,
            timestamp:   m.createdAt,
        }));
    }

    _buildHTML(messages, ticket, guild) {
        const openedAt = new Date(ticket.opened_at * 1000).toUTCString();
        const closedAt = ticket.closed_at ? new Date(ticket.closed_at * 1000).toUTCString() : 'N/A';
        const answers  = ticket.answers ?? {};

        const messageRows = messages.map(m => this._renderMessage(m)).join('\n');
        const answersHtml = Object.keys(answers).length
            ? this._renderAnswers(answers)
            : '';

        return Buffer.from(`<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Ticket #${ticket.ticket_number} — ${this._esc(ticket.ticket_name)}</title>
<style>${TRANSCRIPT_CSS}</style>
</head>
<body>
<div class="wrapper">
  <div class="header">
    <h1>Ticket #${ticket.ticket_number} — ${this._esc(ticket.ticket_name)}</h1>
    <div class="meta-grid">
      <div class="meta-item"><label>Server</label>   <span>${this._esc(guild?.name ?? 'Unknown')}</span></div>
      <div class="meta-item"><label>Opened By</label><span>${ticket.user_id}</span></div>
      <div class="meta-item"><label>Opened At</label><span>${openedAt}</span></div>
      <div class="meta-item"><label>Closed At</label><span>${closedAt}</span></div>
      <div class="meta-item"><label>Messages</label> <span>${messages.length}</span></div>
      <div class="meta-item"><label>Status</label>   <span class="status-${ticket.status}">${ticket.status.toUpperCase()}</span></div>
      ${ticket.closed_by ? `<div class="meta-item"><label>Closed By</label><span>${ticket.closed_by}</span></div>` : ''}
    </div>
  </div>

  ${answersHtml}

  <div class="messages">
    <div class="messages-header">${messages.length} messages</div>
    ${messageRows || '<div class="empty">No messages recorded.</div>'}
  </div>

  <div class="footer">Generated by Midnight Bot &bull; ${new Date().toUTCString()}</div>
</div>
<script>
  document.querySelectorAll('.spoiler').forEach(el => {
    el.addEventListener('click', () => el.classList.add('revealed'));
  });
</script>
</body>
</html>`, 'utf8');
    }

    _renderMessage(m) {
        const time   = m.timestamp instanceof Date ? m.timestamp : new Date(m.timestamp);
        const ts     = time.toLocaleString('en-US', { hour12: false, timeZone: 'UTC' }) + ' UTC';
        const avatar = m.authorAvatar ?? this._defaultAvatar(m.authorId);

        // Build content: escape HTML first, then linkify, then apply markdown.
        // Order matters: escape must come first so user content can't inject HTML.
        // Linkify must come BEFORE markdown so URLs inside bold/italic still render.
        // However the markdown regexes operate on escaped text and produce HTML,
        // so linkify can safely run after escaping and before markdown tags are inserted.
        const content = m.content
            ? this._applyMarkdown(this._linkify(this._esc(m.content)))
            : '';

        const attachmentsHtml = (m.attachments ?? []).map(a => {
            if (a.contentType?.startsWith('image/')) {
                return `<a href="${a.url}" target="_blank" rel="noopener"><img class="attach-img" src="${a.url}" alt="${this._esc(a.name)}"/></a>`;
            }
            return `<a class="attach-file" href="${a.url}" target="_blank" rel="noopener">[attachment] ${this._esc(a.name)}</a>`;
        }).join('');

        const embedNote = m.embedCount > 0
            ? `<span class="embed-note">[${m.embedCount} embed${m.embedCount !== 1 ? 's' : ''}]</span>`
            : '';

        return `
<div class="msg">
  <img class="avatar" src="${avatar}" alt=""/>
  <div class="msg-body">
    <div class="msg-header">
      <span class="author">${this._esc(m.authorTag)}</span>
      ${m.isBot ? '<span class="bot-tag">BOT</span>' : ''}
      <span class="time">${ts}</span>
    </div>
    ${content   ? `<div class="msg-content">${content}</div>` : ''}
    ${embedNote}
    ${attachmentsHtml ? `<div class="attachments">${attachmentsHtml}</div>` : ''}
  </div>
</div>`;
    }

    _renderAnswers(answers) {
        const items = Object.entries(answers)
            .map(([q, a]) => `<div class="answer"><strong>${this._esc(q)}</strong><p>${this._esc(a)}</p></div>`)
            .join('');
        return `<div class="answers"><h3>Ticket Answers</h3>${items}</div>`;
    }

    _defaultAvatar(userId) {
        try {
            return `https://cdn.discordapp.com/embed/avatars/${(BigInt(userId) >> 22n) % 6n}.png`;
        } catch {
            return 'https://cdn.discordapp.com/embed/avatars/0.png';
        }
    }

    // -------------------------------------------------------------------------
    // Text processing
    // -------------------------------------------------------------------------

    /** HTML-escapes a string. Must be called before any other text transformation. */
    _esc(str) {
        if (!str) return '';
        return str
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;');
    }

    /**
     * Turns http(s) URLs in already-escaped text into anchor tags.
     * Runs before _applyMarkdown so URLs inside bold/italic text still link correctly.
     */
    _linkify(str) {
        // The URL in escaped text will use &amp; etc, so we match the raw URL characters.
        return str.replace(/(https?:\/\/[^\s<>&"]+)/g, '<a href="$1" target="_blank" rel="noopener">$1</a>');
    }

    /**
     * Converts a subset of Discord markdown to HTML.
     * Operates on already HTML-escaped + linkified text.
     * Code blocks are handled first to prevent other rules matching inside them.
     */
    _applyMarkdown(str) {
        return str
            .replace(/```(?:\w+\n)?([\s\S]*?)```/g, '<pre><code>$1</code></pre>')
            .replace(/`([^`]+)`/g,      '<code>$1</code>')
            .replace(/\*\*(.+?)\*\*/g,  '<strong>$1</strong>')
            .replace(/\*(.+?)\*/g,      '<em>$1</em>')
            .replace(/_(.+?)_/g,        '<em>$1</em>')
            .replace(/~~(.+?)~~/g,      '<del>$1</del>')
            .replace(/\|\|(.+?)\|\|/g,  '<span class="spoiler">$1</span>')
            .replace(/^&gt; (.+)$/gm,   '<blockquote>$1</blockquote>');
    }
}

// ---------------------------------------------------------------------------
// Stylesheet (kept out of _buildHTML to keep template clean)
// ---------------------------------------------------------------------------

const TRANSCRIPT_CSS = `
  :root {
    --bg:     #313338;
    --bg2:    #2b2d31;
    --bg3:    #1e1f22;
    --text:   #dbdee1;
    --muted:  #949ba4;
    --accent: #5865f2;
    --green:  #23a55a;
    --red:    #f23f43;
    --radius: 8px;
    --font:   'gg sans', 'Noto Sans', system-ui, sans-serif;
  }
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  body { background: var(--bg3); color: var(--text); font-family: var(--font); font-size: 15px; line-height: 1.5; }
  a    { color: #00aff4; text-decoration: none; }
  a:hover { text-decoration: underline; }

  .wrapper  { max-width: 900px; margin: 0 auto; padding: 24px 16px; }

  .header   { background: var(--bg2); border-radius: var(--radius); padding: 24px; margin-bottom: 20px; border-left: 4px solid var(--accent); }
  .header h1 { font-size: 22px; font-weight: 700; margin-bottom: 14px; color: #fff; }

  .meta-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 12px; }
  .meta-item label { font-size: 11px; text-transform: uppercase; letter-spacing: .08em; color: var(--muted); display: block; margin-bottom: 2px; }
  .meta-item span  { font-weight: 600; font-size: 14px; }
  .status-open   { color: var(--green); }
  .status-closed { color: var(--red); }

  .answers   { background: var(--bg2); border-radius: var(--radius); padding: 20px; margin-bottom: 20px; }
  .answers h3 { margin-bottom: 14px; font-size: 15px; font-weight: 700; }
  .answer    { margin-bottom: 12px; padding: 10px 14px; background: var(--bg3); border-radius: 6px; border-left: 3px solid var(--accent); }
  .answer strong { display: block; font-size: 13px; color: var(--muted); margin-bottom: 4px; }
  .answer p  { font-size: 14px; white-space: pre-wrap; }

  .messages  { background: var(--bg2); border-radius: var(--radius); padding: 12px 0; }
  .messages-header { padding: 12px 20px; border-bottom: 1px solid rgba(255,255,255,.06); margin-bottom: 8px; font-size: 13px; color: var(--muted); }
  .empty     { padding: 20px; text-align: center; color: var(--muted); }

  .msg       { display: flex; gap: 14px; padding: 6px 20px; border-radius: 4px; }
  .msg:hover { background: rgba(0,0,0,.1); }
  .avatar    { width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0; object-fit: cover; background: var(--bg3); }
  .msg-body  { flex: 1; min-width: 0; }

  .msg-header { display: flex; align-items: baseline; gap: 8px; margin-bottom: 2px; flex-wrap: wrap; }
  .author    { font-weight: 600; color: #fff; font-size: 15px; }
  .time      { font-size: 11px; color: var(--muted); }
  .bot-tag   { background: var(--accent); color: #fff; font-size: 10px; font-weight: 700; padding: 1px 5px; border-radius: 3px; letter-spacing: .04em; }
  .embed-note { font-size: 11px; color: var(--muted); font-style: italic; margin-top: 2px; display: inline-block; }

  .msg-content { color: var(--text); white-space: pre-wrap; word-break: break-word; }
  .msg-content code { background: rgba(0,0,0,.3); padding: 1px 5px; border-radius: 3px; font-family: monospace; font-size: 13px; }
  .msg-content pre  { background: rgba(0,0,0,.3); padding: 10px; border-radius: 6px; overflow-x: auto; margin: 4px 0; }
  .msg-content blockquote { border-left: 3px solid var(--muted); padding-left: 10px; color: var(--muted); }
  .msg-content strong { font-weight: 700; }
  .msg-content em     { font-style: italic; }
  .msg-content del    { text-decoration: line-through; color: var(--muted); }

  .spoiler          { background: var(--text); color: var(--text); border-radius: 3px; cursor: pointer; }
  .spoiler.revealed { color: #fff; }

  .attachments { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 6px; }
  .attach-img  { max-width: 300px; max-height: 200px; border-radius: 6px; display: block; object-fit: contain; background: var(--bg3); }
  .attach-file { display: inline-flex; align-items: center; gap: 4px; background: var(--bg3); padding: 6px 12px; border-radius: 6px; font-size: 13px; color: var(--text); }
  .attach-file:hover { background: var(--bg); }

  .footer { text-align: center; padding: 20px; color: var(--muted); font-size: 12px; }

  @media (max-width: 600px) {
    .avatar { width: 32px; height: 32px; }
    .msg    { gap: 10px; padding: 6px 12px; }
    .meta-grid { grid-template-columns: 1fr 1fr; }
  }
`;

module.exports = new TranscriptGenerator();
